I figured I should keep a more detailed log of my changes to make it easier
for the professor to see what changed and so I myself can see the progress.

7/1/19 1:27AM
+I got a rudementary version of the cursor implemented. Which includes drawing
the screen and getting user input "real time". 

To make this better I can stagger the drawing of the screen. Technically, 
the image doesn't need to change until the user has input something 
(unless I later want to implement idle animation for the units :D).

If I'm doing this with only the Graphics module I have to layer the drawing 
of the screen. The BG obviously goes on the bottom (terrain), then the unit,
then the cursor with a transparent middle (only draw the edges the 
cursor is highlighting).

As for the hud with information I'd like to implement, maybe I can make the 
screen a bit larger (by one grid), fill it with a neutral color and put text
over it for the info about unit/terrain.

I thought about using an image editor to draw the BG image png and importing
it to the screen but that would mean the tiles would be set on loading.
Instead, I think I should draw tile types (forest, ground, mountain/hill)
and load them per tile on the grid. I think I can compile them all once, save
it, and redraw when the screen updates.

Since I'm at it I think I'll make the cursor just a border and commit the files.

7/3/19 6:32PM
+Added the boundry box so the users cursor can't be out of bounds. This
change was made possible by adding a (w,h) param to the push function.

7:39PM
+Made the 2D list to hold tile types and drew a single tile for testing. Now
I have to make the position variable depending on the board list and the tile
base color reflect the tile type. I'm commiting this now because my battery
bank is getting low on power and I'm at a cafe.. I would hate to lose any 
progress lol

8:49PM
+Drew the actual game tiles by taking a 2D list of terrain types. 
As of now, the gameboard is being drawn every state update but it doesn't 
have to be. It can be initialized once into a single image with blit_image
maybe?? Anyways, I'm just super stoked it worked like the pseudocode from my
notebook!

7/7/19 11:28PM
I thought I had another week! Turns out tomorrow is the project presentation.. 
FML I even requested a few extra days off next week so I can focus on the project..
I should have paid attention to the due dates. ANYWAYS, now I'm trying to get a place holder
for unit sprites to work. I thought it would be as simple as plugging them into imagelib
and graphics but turns out size is a big problem.

7/9/19 4:57AM
+Added in the Select and Cancel type for user input.

I was laying in bed and my mind kept running with ideas I wanted to try so I
got up and decided to run with it. I initally wanted to make a record type
for the units but then started thinking about how they would integrate with
the game grid. Maybe I could change the list type of the grid to also hold
unit type? Currently the gameboard is a 2D list of type terrain. If I change
the list type to (terrain * unit) then I can draw the terrain and units on
the screen at once..

But then another problem arises. How about the relationship between the 
cursor and the terrain/units? How would I translate the cursor position to
the grid? 

Here are some thoughts:
  The cursor is a state of (x, y) coordinates. So if the cursor is at (0, 0)
I know that it's highlighting the first element in the first list of terrain
list or [ [0], _ ]. If the cursor is at (1unit, 0) of the grid, it's at 
[ [1], _] of the board. 
  So the ypos of the cursor is the n'th list of the list and the xpos is 
the m'th element of the n'th list. If the list of terrain type was stored
in an array that can be reffered to by index this would make selecting a 
point on the board a whole lot easier..
  I vaguely remember seeing an Array module somewhere.. Time to google!
  So it turns out there is an Array module! :D but I've never used it before.
If I want to use an array in the program, I'll have to make a bunch of 
changes.. Let's test the Array module on utop before messing with the main
program.

